#Java中基本数据类型byte的溢出问题
问题源于：[Day2](file:///F:/github/JavaFile/JavaBasic/JavaSEBasic/Day2.md)

定义两个byte类型的数据，将其之和赋值给一个新的byte类型数据
```
byte b1 = 1;
byte b2 = 2;
byte b = (byte)(b1+b2);
System.out.println(b);
```
此时结果为3，与预期一致

byte类型的数据范围为-127~128，猜想，若此时将上述代码改成
```
byte b1 = 67;
byte b2 = 89;
byte b = (byte)(b1+b2);
System.out.println(b);
```
此时编译器会不会报错？
进入cmd执行命令

![3ReF8H.png](https://s2.ax1x.com/2020/03/02/3ReF8H.png)

结果是-100？！

上面提到byte类型的取值范围是-128~127
这个输出结果是由java编码方式决定的，Java中正数用原码表示，负数用补码表示，第一位是符号位，正数和0用0标记，负数用1标记。

byte类型的数据占用**1字节**，即8位，但是在进行相加运算时，系统会自动转换为**int**类型(4字节)进行运算

int型整数67的二进制为 `0000 0000 0000 0000 0000 0100 0011‬`
int型整数89的二进制为 `0000 0000 0000 0000 0000 0101 1001‬‬`
相加后，得到的int型整数156的二进制为 `0000 0000 0000 0000 0000 1001 1100‬`
在经过强制类型转换(byte)后，其结果为 `1001 1100`

编码的最高位为1，所以编译器认为这是一个负数
而上述提到，负数用补码表示，需要转换为原码，故取反加1
取反 `0110 0011`
加1 `0110 0100`
也就是100，因为是负数所以添上符号，结果为-100。

##参考资料：
byte类型取值范围以及溢出详解|CSDN
<https://blog.csdn.net/benjamin_whx/article/details/38704077>